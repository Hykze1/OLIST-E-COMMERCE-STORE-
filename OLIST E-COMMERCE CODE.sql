
-- WHAT IS THE TOTAL REVENUE GENERATED BY OLIST, AND HOW HAS IT CHANGED OVER TIME?
--WE JOIN THE TABLE AS REQUIRED


select price,freight_value,payment_value

from olist_order_items_dataset$ item
join olist_order_payments_dataset$ pay
	on item.order_id = pay.order_id

--Let check for dupplicate 
--In most database systems, the primary key of a table is used to uniquely identify each row in that table. Therefore, the primary key 
--column (often named 'order_id') is expected to have unique values for each row, and duplicate values are not allowed.
--Having duplicate values in the primary key column would violate the fundamental principle of data integrity and could lead to
--inconsistencies and errors in the database. Each primary key value serves as a unique identifier for a specific record, and duplicates
--would create ambiguity in identifying and accessing individual records.

select item.order_id,  pay.order_id, count(*)
from olist_order_items_dataset$ item
join olist_order_payments_dataset$ pay
	on item.order_id = pay.order_id

--This is just to check if any of the column has null

--where item.order_id is null
--where item.freight_value is null
--where pay.order_id is null
--where pay.payment_type is null
--where pay.payment_value is null

group by item.order_id,pay.order_id
having count(*)>1

-- lets view some of the duplicate
select item.*,  pay.payment_value
from olist_order_items_dataset$ item
join olist_order_payments_dataset$ pay
	on item.order_id = pay.order_id
where item.order_id = '00f1cc7439ccb8671133776d1829faf5'

-- Now lets delete duplicate in our order_id in olist_order_items_dataset$ item

WITH CTE AS (
    SELECT order_id,
           ROW_NUMBER() OVER (PARTITION BY order_id ORDER BY (SELECT NULL)) AS rn
    FROM olist_order_items_dataset$ item
)
DELETE FROM CTE
WHERE rn > 1;

-- Now lets delete duplicate in our order_id in olist_order_payments_dataset$

WITH CTE AS (
    SELECT order_id,
           ROW_NUMBER() OVER (PARTITION BY order_id ORDER BY (SELECT NULL)) AS rn
    FROM olist_order_payments_dataset$ item
)
DELETE FROM CTE
WHERE rn > 1;

-- Checking if there is still any duplicate

select item.order_id,  pay.order_id, count(*)
from olist_order_items_dataset$ item
join olist_order_payments_dataset$ pay
	on item.order_id = pay.order_id

group by item.order_id,pay.order_id
having count(*)>1

--Lets check the data type by just insering the column desired to check 

SELECT DATA_TYPE
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = 'olist_orders_dataset'
  AND COLUMN_NAME = 'order_purchase_timestamp'
 

  --Now let compute for the total revenue. Total Revenue = (Price of the Product + Shipping Fee) * payment_sequential
  -- This will account for cases where payments are made or multiple payments are associated with a single transaction.
 
select sum (payment_sequential * payment_value) Total_Revenue 
from olist_order_payments_dataset$

-- TO ANALYZE HOW THE TOTAL REVENUE HAS CHANGED OVER TIME, WE'LL NEED TO CONSIDER THE 'TIME' COMPONENT IN OUR DATASET

SELECT 
    LEFT(ORDER_PURCHASE__DATE, 3) AS MONTH,
   ROUND( sum (payment_sequential * payment_value),0) MONTLY_REVENUE
FROM olist_orders_dataset item
join olist_order_payments_dataset$ pay
	on item.order_id = pay.order_id
GROUP BY LEFT(ORDER_PURCHASE__DATE, 3)
ORDER BY MONTLY_REVENUE DESC;

-- Now we create a view for this 

create view TOTAL_REVENUE__OVER_TIME AS
 
 SELECT 
    LEFT(ORDER_PURCHASE__DATE, 3) AS MONTH,
   ROUND( sum (payment_sequential * payment_value),0) MONTLY_REVENUE
FROM olist_orders_dataset item
join olist_order_payments_dataset$ pay
	on item.order_id = pay.order_id
GROUP BY LEFT(ORDER_PURCHASE__DATE, 3)

-- Check the view
SELECT * FROM TOTAL_REVENUE__OVER_TIME

--HOW MANY ORDERS WERE PLACED ON OLIST, AND HOW DOES THIS VARY BY MONTH OR SEASON? 
-- FIRSTLY WE CHECK FOR DUPLICATE USING CTE
 
WITH CTE AS (
    SELECT order_id, customer_id, 
           ROW_NUMBER() OVER (PARTITION BY order_id, customer_id ORDER BY (SELECT NULL)) AS rn
    FROM olist_orders_dataset
)
SELECT *
FROM CTE
WHERE rn > 1;

 --check for duplicate using SELECT

select order_id, customer_id, count(*)
from olist_orders_dataset
group by order_id, customer_id
having count(*) >1

-- Since no duplicate, we then have to split colunms that time and date
-- Normally , i am suppose to use this syntax 
--SELECT DATE(datetime_column) AS date_column
--FROM your_table;
--for easy spliting but unfortunately my sql do not have the built-in function, i could use python for easier spliting. 
--Nevertheless lets use LEFT 
SELECT LEFT(order_purchase_timestamp,11) ORDER_PURCHASE_DATE, RIGHT( order_purchase_timestamp, 7)ORDER_PURCHASE_TIME,
		LEFT(order_approved_at,11) ORDER_APPROVED_DATE, RIGHT( order_approved_at, 7) ORDER_APPROVED_TIME,
		LEFT(order_delivered_carrier_date,11) ORDER_DELIVERED_CARRIER_DATE, RIGHT( order_delivered_carrier_date, 7) ORDER_DELIVERED_CARRIER_TIME,
		LEFT(order_delivered_customer_date,11) ORDER_DELIVERED_CUSTOMER_DATE, RIGHT( order_delivered_customer_date, 7) ORDER_DELIVERED_CUSTOMER_TIME,
		LEFT(order_estimated_delivery_date,11) ORDER_ESTIMATED_DELIVERY_DATE,RIGHT( order_estimated_delivery_date, 7) ORDER_ESTIMATED_DELIVERY_TIME
FROM olist_orders_dataset

--NOW WE CREATE A TABLE FOR THEM
ALTER TABLE olist_orders_dataset
ADD ORDER_PURCHASE__DATE NVARCHAR(13), ORDER_PURCHASE__TIME  NVARCHAR (13), ORDER_APPROVED__DATE  NVARCHAR (13),ORDER_APPROVED__TIME  NVARCHAR (13)
,ORDER_DELIVERED_CARRIER__DATE  NVARCHAR (13), ORDER_DELIVERED_CARRIER__TIME  NVARCHAR (13), ORDER_DELIVERED_CUSTOMER__DATE  NVARCHAR (13)
, ORDER_DELIVERED_CUSTOMER__TIME NVARCHAR (13), ORDER_ESTIMATED_DELIVERY__DATE  NVARCHAR (13), ORDER_ESTIMATED_DELIVERY__TIME  NVARCHAR (13);

UPDATE olist_orders_dataset
SET ORDER_PURCHASE__DATE = LEFT(order_purchase_timestamp,11),
	ORDER_PURCHASE__TIME = RIGHT(order_purchase_timestamp,7),
	ORDER_APPROVED__DATE = LEFT(order_approved_at,11),
	ORDER_APPROVED__TIME = RIGHT(order_approved_at,7),
	ORDER_DELIVERED_CARRIER__DATE = LEFT(order_delivered_carrier_date,11),
	ORDER_DELIVERED_CARRIER__TIME = RIGHT(order_delivered_carrier_date,7),
	ORDER_DELIVERED_CUSTOMER__DATE = LEFT(order_delivered_customer_date,11),
	ORDER_DELIVERED_CUSTOMER__TIME = RIGHT(order_delivered_customer_date,7), 
	ORDER_ESTIMATED_DELIVERY__DATE = LEFT(order_estimated_delivery_date,11),
	ORDER_ESTIMATED_DELIVERY__TIME = RIGHT(order_estimated_delivery_date,7)
FROM olist_orders_dataset

 -- NOW LETS CHECK HOW MANY ORDER PLACED

 SELECT COUNT(ORDER_PURCHASE__DATE) AS TOTAL_ORDERS
 FROM olist_orders_dataset
 ORDER BY TOTAL_ORDERS

 -- AND

 SELECT ORDER_PURCHASE__DATE, COUNT(*) AS TOTAL_ORDERS
 FROM olist_orders_dataset
 GROUP BY ORDER_PURCHASE__DATE
 ORDER BY TOTAL_ORDERS DESC


 -- LET ANALYZE HOW THE NUMBER OF ORDERS VARIES BY MONTH

SELECT LEFT(ORDER_PURCHASE__DATE,3) AS ORDER_MONTH, COUNT(*) AS TOTAL_ORDERS
FROM olist_orders_dataset
GROUP BY LEFT(ORDER_PURCHASE__DATE,3)
ORDER BY TOTAL_ORDERS

CREATE VIEW ORDER_BY_MONTH AS

SELECT LEFT(ORDER_PURCHASE__DATE,3) AS ORDER_MONTH, COUNT(*) AS TOTAL_ORDERS
FROM olist_orders_dataset
GROUP BY LEFT(ORDER_PURCHASE__DATE,3)


 -- LETS Analyze how the number of orders varies by SEASON
 SELECT
  CASE
    WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Dec', 'Jan', 'Feb') THEN 'Winter'
    WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Mar','Apr' , 'May') THEN 'Spring'
    WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Jun', 'Jul', 'Aug') THEN 'Summer'
    WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Sep', 'Oct', 'Nov') THEN 'Fall'
  END AS ORDER_SEASON,COUNT(*) AS TOTAL_ORDERS
FROM olist_orders_dataset
GROUP BY CASE WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Dec', 'Jan', 'Feb') THEN 'Winter'
    WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Mar','Apr' , 'May') THEN 'Spring'
    WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Jun', 'Jul', 'Aug') THEN 'Summer'
    WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Sep', 'Oct', 'Nov') THEN 'Fall'
	END;

CREATE VIEW ORDER_BY_SEASON AS
 SELECT
  CASE
    WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Dec', 'Jan', 'Feb') THEN 'Winter'
    WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Mar','Apr' , 'May') THEN 'Spring'
    WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Jun', 'Jul', 'Aug') THEN 'Summer'
    WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Sep', 'Oct', 'Nov') THEN 'Fall'
  END AS ORDER_SEASON,COUNT(*) AS TOTAL_ORDERS
FROM olist_orders_dataset
GROUP BY CASE WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Dec', 'Jan', 'Feb') THEN 'Winter'
    WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Mar','Apr' , 'May') THEN 'Spring'
    WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Jun', 'Jul', 'Aug') THEN 'Summer'
    WHEN LEFT(ORDER_PURCHASE__DATE,3) IN ('Sep', 'Oct', 'Nov') THEN 'Fall'
	END;


--WHAT ARE THE MOST POPULAR PRODUCT CATEGORIES ON OLIST

SELECT PD.product_category_name, COUNT(*) MOST_POPULAR_CATEGORY

FROM olist_products_dataset$ PD
where PD.product_category_name is not null
 GROUP BY  PD.product_category_name
 ORDER BY PD.product_category_name DESC


 CREATE VIEW POPULAR_PRODUCT AS
 SELECT PD.product_category_name, COUNT(*) MOST_POPULAR_CATEGORY
FROM olist_products_dataset$ PD
where PD.product_category_name is not null
 GROUP BY  PD.product_category_name
 

--  WHAT IS THE AVERAGE ORDER VALUE (AOV) ON OLIST, AND HOW DOES THIS VARY BY  PAYMENT METHOD?

SELECT round(AVG(payment_value),0) AVERAGE_ORDER_VALUE
FROM olist_order_payments_dataset$ 
order by AVERAGE_ORDER_VALUE

-- HOW DOES THIS VARY BY PAYMENT METHOD? 

SELECT  payment_type,  round(AVG(payment_value),0) AVERAGE_ORDER_VALUE
FROM olist_order_payments_dataset$ 
--where payment_type = 'not_defined'
GROUP BY  payment_type
order by payment_type

CREATE VIEW AVG_ORDER_PAYMENT_METHOD AS

SELECT  payment_type,  round(AVG(payment_value),0) AVERAGE_ORDER_VALUE
FROM olist_order_payments_dataset$ 
--where payment_type = 'not_defined'
GROUP BY  payment_type


-- We can delete the row where payment_type = 'not_defined'
DELETE FROM olist_order_payments_dataset$
where payment_type = 'not_defined'

-- HOW MANY SELLERS ARE ACTIVE ON OLIST, AND HOW DOES THIS NUMBER CHANGE OVER TIME?

SELECT SUM(price + freight_value) TOTAL_SALES, COUNT(SD.seller_id) ACTIVE_SELLERS
FROM olist_sellers_dataset SD
JOIN olist_order_items_dataset$ OID
ON SD.seller_id = OID.seller_id
JOIN olist_products_dataset$ PD
ON OID.product_id = PD.product_id


-- HOW DOES THIS NUMBER CHANGE OVER TIME?

SELECT DATEPART (MONTH,TRANSACTION_DATE) MONTH, COUNT(seller_id) SELLERS_MONTHLY
FROM olist_order_items_dataset$
GROUP BY DATEPART (MONTH,TRANSACTION_DATE)
--ORDER BY MONTH

--WHAT IS THE DISTRIBUTION OF SELLER RATINGS ON OLIST, AND HOW DOES THIS IMPACT SALES PERFORMANCE?  
-- FIRST WE HAVE TO EXTRACT DATE AND TIME FROM REVIEWS.

SELECT left(review_creation_date,11) REVIEW_CREATION_DATE , LEFT(review_answer_timestamp,11) REVIEW_ANSWER_DATE,
		RIGHT(review_answer_timestamp,7) REVIEW_ANSWER_TIME
from olist_order_reviews_dataset$

-- NOW WE ADD AS COLUMN 

ALTER TABLE olist_order_reviews_dataset$
ADD REVIEW__CREATION_DATE DATE, REVIEW_ANSWER_DATE DATE, REVIEW_ANSWER_TIME TIME

-- WE POPULATE THE COLUMN

UPDATE olist_order_reviews_dataset$
SET REVIEW__CREATION_DATE = left(review_creation_date,11), 
	REVIEW_ANSWER_DATE = LEFT(review_answer_timestamp,11),
	REVIEW_ANSWER_TIME = RIGHT(review_answer_timestamp,7) 

--Now let find the distribution of seller ratings on Olist

SELECT review_score,  COUNT(*) AS SELLER_RATING_COUNT
FROM olist_order_items_dataset$ OID
JOIN olist_order_reviews_dataset$ ORD
ON OID.order_id = ORD.order_id

GROUP BY review_score
ORDER BY review_score DESC;

-- LET ANALYZE SALES PERFORMANCE BASED ON SELLER RATINGS:

SELECT seller_id, review_score , COUNT(*) AS ORDER_COUNT, SUM(price + freight_value) AS TOTAL_SALES
FROM olist_order_items_dataset$ OID
JOIN olist_order_reviews_dataset$ ORD
ON OID.order_id = ORD.order_id
GROUP BY Seller_id, review_score 
ORDER BY TOTAL_SALES DESC;

-- WHAT IS THE AVERAGE CUSTOMER RATING FOR PRODUCTS SOLD ON OLIST, AND HOW DOES THIS IMPACT SALES PERFORMANCE? 

SELECT 
    AVG(review_score) AS AVG_RATING,
    SUM(payment_value) AS TOTAL_SALES
FROM olist_order_payments_dataset$ OID
JOIN olist_order_reviews_dataset$ ORD
ON OID.order_id = ORD.order_id

--HOW DOES THIS IMPACT SALES PERFORMANCE? 

--Analyzing the impact on sales performance:WE can then further analyze the relationship between average product rating and sales 
--performance. BY can dividing the products into categories based on their ratings (e.g., high-rated, medium-rated, low-rated) 
--and calculate sales performance metrics for each

SELECT 
    CASE
        WHEN review_score >= 4.5 THEN 'High Rated'
        WHEN review_score >= 3.5 THEN 'Medium Rated'
        ELSE 'Low Rated'
    END AS RATING_CATEGORY,
    COUNT(*) AS PRODUCT_COUNT,
   round(SUM(payment_value),0) AS TOTAL_SALE
FROM olist_order_payments_dataset$ OID
JOIN olist_order_reviews_dataset$ ORD
ON OID.order_id = ORD.order_id
GROUP BY CASE
        WHEN review_score >= 4.5 THEN 'High Rated'
        WHEN review_score >= 3.5 THEN 'Medium Rated'
        ELSE 'Low Rated'
    END 


--By analyzing the sales performance across different rating categories, you can gain insights into how the average customer rating 
--impacts product sales on the OLIST platform.

create view CUSTOMER_RATING_ON_SALE AS

SELECT 
    CASE
        WHEN review_score >= 4.5 THEN 'High Rated'
        WHEN review_score >= 3.5 THEN 'Medium Rated'
        ELSE 'Low Rated'
    END AS RATING_CATEGORY,
    COUNT(*) AS PRODUCT_COUNT,
   round(SUM(payment_value),0) AS TOTAL_SALE
FROM olist_order_payments_dataset$ OID
JOIN olist_order_reviews_dataset$ ORD
ON OID.order_id = ORD.order_id
GROUP BY CASE
        WHEN review_score >= 4.5 THEN 'High Rated'
        WHEN review_score >= 3.5 THEN 'Medium Rated'
        ELSE 'Low Rated'
    END 

-- WHAT IS THE AVERAGE ORDER CANCELLATION RATE ON OLIST, AND HOW DOES THIS IMPACT SELLER PERFORMANCE

SELECT 
	seller_id,
    COUNT(CASE WHEN order_status = 'canceled' THEN 1 ELSE NULL END) AS CANCELED_ORDER_COUNT, COUNT(*) AS TOTAL_ORDER,
    100.0 * COUNT(CASE WHEN order_status = 'canceled' THEN 1 ELSE NULL END) / COUNT(*) AS CANCELLATION_RATE
FROM olist_orders_dataset OID
JOIN olist_order_items_dataset$ ORD
ON OID.order_id = ORD.order_id
--WHERE COUNT(CASE WHEN order_status = 'canceled' THEN 1 ELSE NULL END) <> '0'
GROUP BY seller_id
HAVING COUNT(CASE WHEN order_status = 'canceled' THEN 1 ELSE NULL END) <> '0'

--WHAT ARE THE TOP-SELLING PRODUCTS ON OLIST, AND HOW HAVE THEIR SALES TRENDS CHANGED OVER TIME?

SELECT TOP 5 product_category_name , ROUND(SUM( price + freight_value),0) TOP_SELLING_PRODUCT
FROM olist_order_items_dataset$ OID
right JOIN olist_products_dataset$ ORD
ON OID.product_id = ORD.product_id
where product_category_name is not null
group by product_category_name
ORDER BY TOP_SELLING_PRODUCT DESC

create view TO_SELLING_PRODUCT AS

SELECT TOP 5 product_category_name , ROUND(SUM( price + freight_value),0) TOP_SELLING_PRODUCT
FROM olist_order_items_dataset$ OID
right JOIN olist_products_dataset$ ORD
ON OID.product_id = ORD.product_id
where product_category_name is not null
group by product_category_name


--HOW HAVE THEIR SALES TRENDS CHANGED OVER TIME?

-- But we need our transaction or order date even shipping limit day to figure out the trend change, we will do that by 
--spliting the column into date and time

-- NOW LET SEE HOW sales trends changed over time

SELECT left(shipping_limit_date,11) TRANSACTION_DATE, right(shipping_limit_date,7) TRANSACTION_TIME
from olist_order_items_dataset$

ALTER TABLE olist_order_items_dataset$
ADD TRANSACTION_DATE DATE, TRANSACTION_TIME TIME

UPDATE olist_order_items_dataset$
	SET TRANSACTION_DATE = left(shipping_limit_date,11),
		TRANSACTION_TIME = right(shipping_limit_date,7) 

--NOW LETS COMPARE THEIR SALES VOLUME


SELECT LEFT (ORDER_PURCHASE__DATE, 3) MONTH,
		 ROUND(SUM( price + freight_value),0) TOP_SELLING_PRODUCT
FROM  olist_orders_dataset OOD
JOIN olist_order_items_dataset$ OID
ON OOD.order_id = OID.order_id
JOIN olist_products_dataset$ PD
ON OID.product_id = PD.product_id
where product_category_name is not null
group by LEFT (ORDER_PURCHASE__DATE, 3)
ORDER BY TOP_SELLING_PRODUCT DESC


CREATE VIEW TOP_SELLING_PRODUCT_BY_MONTH AS

SELECT LEFT (ORDER_PURCHASE__DATE, 3) MONTH,
		 ROUND(SUM( price + freight_value),0) TOP_SELLING_PRODUCT
FROM  olist_orders_dataset OOD
JOIN olist_order_items_dataset$ OID
ON OOD.order_id = OID.order_id
JOIN olist_products_dataset$ PD
ON OID.product_id = PD.product_id
where product_category_name is not null
group by LEFT (ORDER_PURCHASE__DATE, 3)


-- WE CAN ALSO SAY 
SELECT LEFT (ORDER_PURCHASE__DATE, 3) MONTH,
		 SUM( price + freight_value) TOP_SELLING_PRODUCT,
		 CASE
		 WHEN SUM( price + freight_value) >= 1500000 THEN 'HIGH_SALE_VOLUME' 
		 WHEN SUM( price + freight_value) BETWEEN 900000 AND 1499999 THEN 'MEDIUM_SALE_VOLUME' 
		 ELSE 'LOW_SALE_VOLUME' 
		 END AS SALES_VOLUME_RATING

FROM olist_orders_dataset OOD
JOIN olist_order_items_dataset$ OID
ON OOD.order_id = OID.order_id
JOIN olist_products_dataset$ PD
ON OID.product_id = PD.product_id
where LEFT (ORDER_PURCHASE__DATE, 3) is not null
group by LEFT (ORDER_PURCHASE__DATE, 3)
ORDER BY TOP_SELLING_PRODUCT DESC

--WHICH PAYMENT METHODS ARE MOST COMMONLY USED BY OLIST CUSTOMERS, AND HOW DOES THIS VARY BY PRODUCT CATEGORY? 

SELECT payment_type, count(*) COMMON_PAYMENT_METOD
FROM olist_orders_dataset OID
JOIN olist_order_payments_dataset$ ORD
ON OID.order_id = ORD.order_id
group by payment_type

CREATE VIEW COMMONEST_PAYMENT_METHOD AS

SELECT payment_type, count(*) COMMON_PAYMENT_METOD
FROM olist_orders_dataset OID
JOIN olist_order_payments_dataset$ ORD
ON OID.order_id = ORD.order_id
group by payment_type


-- HOW DOES THIS VARY BY  GEOGRAPHIC REGION? 

SELECT   payment_type, COUNT(customer_city) CUSTOMER_GEOGRAPHICAL_REGION
FROM olist_order_payments_dataset$ PAY
JOIN olist_orders_dataset OD 
ON PAY.order_id = OD.order_id
JOIN olist_customers_dataset$ GEO ON OD.customer_id = GEO.customer_id
group by  payment_type

-- OR 

SELECT   customer_city, payment_type, COUNT(*) CUSTOMER_GEOGRAPHICAL_REGION
FROM olist_order_payments_dataset$ PAY
JOIN olist_orders_dataset OD 
ON PAY.order_id = OD.order_id
JOIN olist_customers_dataset$ GEO 
ON OD.customer_id = GEO.customer_id
group by  payment_type, customer_city
ORDER BY CUSTOMER_GEOGRAPHICAL_REGION DESC

--ALSO BY product category

SELECT   payment_type, product_category_name PAYMENT_TYPE_BY_CATEGORY
FROM olist_order_payments_dataset$ PAY
JOIN olist_order_items_dataset$ OID 
ON PAY.order_id = OID.order_id
JOIN olist_products_dataset$ GEO 
ON OID.product_id = GEO.product_id
group by payment_type, product_category_name
ORDER BY PAYMENT_TYPE_BY_CATEGORY DESC

--11 How do customer reviews and ratings affect sales and product performance on Olist? 

SELECT review_score,SUM (payment_value) TOTAL_SALES, COUNT(product_category_name) PRODUCT_CATEGORY_COUNT
FROM olist_order_reviews_dataset$ ORD
JOIN olist_order_payments_dataset$ PAY
ON ORD.order_id = PAY.order_id
JOIN olist_order_items_dataset$ OID
ON PAY.order_id = OID.order_id
JOIN olist_products_dataset$ PD
ON OID.product_id = PD.product_id
GROUP BY review_score
ORDER BY 1 DESC

CREATE VIEW CUS_RATING_ND_SALES AS
SELECT review_score,SUM (payment_value) TOTAL_SALES, COUNT(product_category_name) PRODUCT_CATEGORY_COUNT
FROM olist_order_reviews_dataset$ ORD
JOIN olist_order_payments_dataset$ PAY
ON ORD.order_id = PAY.order_id
JOIN olist_order_items_dataset$ OID
ON PAY.order_id = OID.order_id
JOIN olist_products_dataset$ PD
ON OID.product_id = PD.product_id
GROUP BY review_score

--WHICH PRODUCT CATEGORIES HAVE THE HIGHEST PROFIT MARGINS ON OLIST, AND HOW CAN THE COMPANY INCREASE PROFITABILITY 
--ACROSS DIFFERENT CATEGORIES?


SELECT TOP 5 -- Adjust the LIMIT value to retrieve more or fewer categories with the highest profit margins
    product_category_name,
	(SUM(payment_value) - SUM(price) - SUM(freight_value)) / SUM(payment_value) AS PROFIT_MARGIN
    --AVG(((payment_value - price) - freight_value) / price) AS PROFIT_MARGIN
FROM olist_order_reviews_dataset$ ORD
JOIN olist_order_payments_dataset$ PAY
ON ORD.order_id = PAY.order_id
JOIN olist_order_items_dataset$ OID
ON PAY.order_id = OID.order_id
JOIN olist_products_dataset$ PD
ON OID.product_id = PD.product_id
WHERE product_category_name IS NOT NULL
GROUP BY
    product_category_name
ORDER BY
    PROFIT_MARGIN DESC

CREATE VIEW HIGHEST_PROFIT_MARGIN AS

SELECT TOP 5 -- Adjust the LIMIT value to retrieve more or fewer categories with the highest profit margins
    product_category_name,
	(SUM(payment_value) - SUM(price) - SUM(freight_value)) / SUM(payment_value) AS PROFIT_MARGIN
    --AVG(((payment_value - price) - freight_value) / price) AS PROFIT_MARGIN
FROM olist_order_reviews_dataset$ ORD
JOIN olist_order_payments_dataset$ PAY
ON ORD.order_id = PAY.order_id
JOIN olist_order_items_dataset$ OID
ON PAY.order_id = OID.order_id
JOIN olist_products_dataset$ PD
ON OID.product_id = PD.product_id
WHERE product_category_name IS NOT NULL
GROUP BY
    product_category_name


-- how can the company increase profitability across different categories? 

--Pricing Strategies: Analyze pricing for products in different categories. If the profit margins are low, consider adjusting prices based on market demand and competitive analysis.

--Cost Optimization: Look for opportunities to optimize the cost of goods sold and shipping costs without compromising product quality and customer experience.

--Upselling and Cross-selling: Encourage customers to purchase additional items (upselling) or related products (cross-selling) to increase the average order value and overall profitability.

--Marketing and Promotion: Invest in targeted marketing campaigns to drive higher sales for high-profit margin product categories.

--Customer Retention: Focus on customer retention strategies to encourage repeat purchases, as acquiring new customers can be more expensive

--CONCLUSION :
--It's important to conduct a thorough analysis of each product category and consider the specific dynamics of your e-commerce business. 
--Data-driven decision-making and regular monitoring of key performance indicators will be essential to increasing profitability across 
--different categories. Additionally, customer feedback and market research can provide valuable insights to guide your strategies for growth 
--and profitability.

-- Lastly let drop unnecessary  column
ALTER TABLE olist_order_reviews_dataset$
DROP COLUMN review_comment_title, review_comment_message, review_creation_date,review_answer_timestamp

ALTER TABLE olist_order_items_dataset$ 
DROP COLUMN CANCELED_ORDER_COUNT, TOTAL_ORDER

ALTER TABLE olist_orders_dataset
DROP COLUMN order_purchase_timestamp, order_approved_at, order_delivered_carrier_date,order_delivered_customer_date,
			order_estimated_delivery_date

ALTER TABLE olist_order_items_dataset$ 
DROP COLUMN order_item_id, shipping_limit_date



ALTER TABLE olist_products_dataset$
DROP COLUMN product_name_lenght, product_description_lenght, product_photos_qty, product_weight_g, product_lenght_cm,
			product_height_cm, product_width_cm
	

select * from olist_products_dataset$



-- TO RENMAE COLUMN
EXEC sp_rename 'olist_order_reviews_dataset$.review_id', 'REVIEW_ID', 'COLUMN';
EXEC sp_rename 'olist_order_reviews_dataset$.order_id', 'ORDER_ID', 'COLUMN';
EXEC sp_rename 'olist_order_reviews_dataset$.review_score', 'REVIEW_SCORE', 'COLUMN';

EXEC sp_rename 'olist_order_payments_dataset$.order_id', 'ORDER_ID', 'COLUMN';
EXEC sp_rename 'olist_order_payments_dataset$.payment_sequential', 'PAYMENT_SEQUENTIAL', 'COLUMN';
EXEC sp_rename 'olist_order_payments_dataset$.payment_type', 'PAYMENT_TYPE', 'COLUMN';
EXEC sp_rename 'olist_order_payments_dataset$.payment_installments', 'PAYMENT_INSTALLMENT', 'COLUMN';
EXEC sp_rename 'olist_order_payments_dataset$.payment_value', 'PAYMENT_VALUE', 'COLUMN';

EXEC sp_rename 'olist_order_items_dataset$.order_id', 'ORDER_ID', 'COLUMN';
EXEC sp_rename 'olist_order_items_dataset$.product_id', 'PRODUCT_ID', 'COLUMN';
EXEC sp_rename 'olist_order_items_dataset$.seller_id', 'SELLER_ID', 'COLUMN';
EXEC sp_rename 'olist_order_items_dataset$.price', 'PRICE', 'COLUMN';
EXEC sp_rename 'olist_order_items_dataset$.freight_value', 'FREIGHT_VALUE', 'COLUMN';

EXEC sp_rename 'olist_products_dataset$.product_id', 'PRODUCT_ID', 'COLUMN';
EXEC sp_rename 'olist_products_dataset$.product_category_name', 'PRODUCT_CATEGORY_NAME', 'COLUMN';

EXEC sp_rename 'olist_orders_dataset.order_id', 'ORDER_ID', 'COLUMN';
EXEC sp_rename 'olist_orders_dataset.customer_id', 'CUSTOMER_ID', 'COLUMN';
EXEC sp_rename 'olist_orders_dataset.order_status', 'ORDER_STATUS', 'COLUMN';

EXEC sp_rename 'olist_customers_dataset$.customer_id', 'CUSTOMER_ID',  'COLUMN'; 
EXEC sp_rename 'olist_customers_dataset$.customer_unique_id', 'CUSTOMER_UNIQUE_ID',  'COLUMN'; 
EXEC sp_rename 'olist_customers_dataset$.customer_zip_code_prefix', 'CUSTOMER_ZIP_CODE_PREFIX',  'COLUMN'; 
EXEC sp_rename 'olist_customers_dataset$.customer_city', 'CUSTOMER_CITY',  'COLUMN'; 
EXEC sp_rename 'olist_customers_dataset$.customer_state', 'CUSTOMER_STATE',  'COLUMN'; 


select *
FROM olist_order_reviews_dataset$ ORD
JOIN olist_order_payments_dataset$ PAY
ON ORD.order_id = PAY.order_id
JOIN olist_order_items_dataset$ OID
ON PAY.order_id = OID.order_id
JOIN olist_products_dataset$ PD
ON OID.product_id = PD.product_id
JOIN olist_orders_dataset RD
ON  OID.order_id = RD.order_id
JOIN olist_customers_dataset$ CD
ON RD.customer_id = CD.customer_id



SELECT * FROM  AVG_ORDER_PAYMENT_METHOD

